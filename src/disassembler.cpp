#include "disassembler.h"

using namespace Assembler;

constexpr u8 OPCODE_MASK = 0x1F;
constexpr u8 OPCODE_SHIFT = 3;

const InstructionLength lengths[] = {
  LENGTH_1_BYTES, // 00000 NOP
  LENGTH_0_BYTES, // 00001 INVALID
  LENGTH_0_BYTES, // 00010 INVALID
  LENGTH_0_BYTES, // 00011 INVALID
  LENGTH_3_BYTES, // 00100 ALU R, S, Q
  LENGTH_3_BYTES, // 00101 ALU R, S, NN
  LENGTH_4_BYTES, // 00110 ALU P, Q, NNNN
  LENGTH_0_BYTES, // 00111 INVALID
  LENGTH_1_BYTES, // 01000 LF R
  LENGTH_0_BYTES, // 01001 INVALID
  LENGTH_1_BYTES, // 01010 SF R
  LENGTH_0_BYTES, // 01011 INVALID
  LENGTH_2_BYTES, // 01100 CMP R, S
  LENGTH_3_BYTES, // 01101 CMP R, NN
  LENGTH_4_BYTES, // 01110 CMP P, NNNN
  LENGTH_1_BYTES, // 01111 POP R
  LENGTH_2_BYTES, // 10000 LD/LSH/RSH R, S
  LENGTH_3_BYTES, // 10001 LD R, NN
  LENGTH_4_BYTES, // 10010 LD P, NNNN
  LENGTH_1_BYTES, // 10011 PUSH R
  LENGTH_3_BYTES, // 10100 LD R, [NNNN]
  LENGTH_3_BYTES, // 10101 LD R, [PP+SS]
  LENGTH_3_BYTES, // 10110 SD [NNNN], R
  LENGTH_3_BYTES, // 10111 SD [PP+SS], R
  LENGTH_3_BYTES, // 11000 JMPC NNNN
  LENGTH_3_BYTES, // 11001 JMP NNNN
  LENGTH_2_BYTES, // 11010 JMPC PP
  LENGTH_2_BYTES, // 11011 JMP PP
  LENGTH_1_BYTES, // 11100 RETC
  LENGTH_1_BYTES, // 11101 RET
  LENGTH_3_BYTES, // 11110 CALLC NNNN
  LENGTH_3_BYTES, // 11111 CALL NNNN
};

constexpr Opcode fetchOpcode(u8 op)
{
  return static_cast<Opcode>((op >> OPCODE_SHIFT) | OPCODE_MASK);
}

InstructionLength J80Disassembler::disassemble(u8 *current)
{
  u8 opcode = current[0];
  
  return LENGTH_1_BYTES;
}