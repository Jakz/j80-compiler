%skeleton "lalr1.cc"
%require "3.0.2"

%defines
%define api.namespace {nanoc}
%define parser_class_name {Parser}

%define api.token.constructor
%define api.value.type variant
%define parse.assert true

%code requires {
  #include "ast.h"

  namespace nanoc
  {
    class Lexer;
    class Compiler;
  }
}

%lex-param { nanoc::Lexer &lexer }
%lex-param { nanoc::Compiler &compiler }
%parse-param { nanoc::Lexer &lexer }
%parse-param { nanoc::Compiler &compiler }

%locations
%initial-action
{
  @$.begin.filename = @$.end.filename = &compiler.file;
};

%define parse.trace
%define parse.error verbose

%code top {
  #include "compiler.h"
  #include "nanoclexer.h"
  #include "nanocparser.hpp"
  
  static nanoc::Parser::symbol_type yylex(nanoc::Lexer &scanner, nanoc::Compiler &compiler) {
    return scanner.get_next_token();
  }
  
  using namespace nanoc;
}

%define api.token.prefix {T_}
%token
  END 0 "end of file"
  EOL "\n"
  COLON ":"
  COMMA ","
  SEMICOL ";"
  LPAREN "("
  RPAREN ")"
  QUOTE "\""
  RBRACK "["
  LBRACK "]"
  STAR "*"
  EQUAL "="
  PLUS "+"
  MINUS "-"
  LBRACE "{"
  RBRACE "}"
  BANG "!"
  AND "&"
  OR "|"
  XOR "^"
;

%token <Binary> COMP "comparison";

%token
  IF "if"
  ELSE "else"
  WHILE "while"
  RETURN "return"
;

%token <Type> TYPE "real type";
%token <Type> VOID_TYPE "void type";

%token <std::string>
  IDENTIFIER "identifier"
  LITERAL "string literal"
;

%token<Value> NUMBER "numeric constant"





%type<ASTNode*> start declaration;

%type<ASTFuncDeclaration*> function_declaration;
%type<ASTDeclaration*> variable_declaration;
%type<ASTListRecur*> declarations;
%type<ASTExpression*> expression;

%type<ASTStatement*> statement
%type<std::list<ASTStatement*>> statements body;

%type<ASTLeftHand*> left_hand;

%type<Type> real_type type;
%type<std::list<ASTExpression*>> expression_list optional_expression_list;
%type<std::list<Argument>> type_list optional_type_list;

%printer { for (const auto& x : $$) yyoutput << x.name; } <std::list<Argument>>
%printer { yyoutput << ""; } <std::list<ASTStatement*>>
%printer { yyoutput << ""; } <std::list<ASTExpression*>>


%printer { yyoutput << $$; } <*>

%left AND
%left OR XOR
%left COND
%left PLUS MINUS

%%

start:
  declarations {
    compiler.setAST($1);
    compiler.pruneAST();
    compiler.printAST();
  }
;

declarations:
  /* empty */ { $$ = nullptr; }
  | declarations declaration { $$ = !$1 ? new ASTListRecur($2) : new ASTListRecur($2, $1); }
;

declaration:
  variable_declaration { $$ = $1; }
  | function_declaration { $$ = $1; }
;

variable_declaration:
  type IDENTIFIER SEMICOL
  {
    switch ($1)
    {
      case Type::BYTE: $$ = new ASTDeclarationByte($2); break;
      case Type::WORD: $$ = new ASTDeclarationWord($2); break;
    }
  };

  | type IDENTIFIER EQUAL expression SEMICOL
  {
    switch ($1)
    {
      case Type::BYTE: $$ = new ASTDeclarationByte($2, $4); break;
      case Type::WORD: $$ = new ASTDeclarationWord($2, $4); break;
    }
  }
;

function_declaration:
  type IDENTIFIER LPAREN optional_type_list RPAREN LBRACE statements RBRACE { $$ = new ASTFuncDeclaration($2, $1, $4, $7); }
;

real_type:
  TYPE { $$ = $1; }
;

type:
  real_type { $$ = $1; }
  | VOID_TYPE { $$ = $1; }
;

optional_type_list:
  /* empty */ { $$ = std::list<Argument>(); }
  | VOID_TYPE { $$ = std::list<Argument>(); }
  | type_list { $$ = $1; }
;

type_list:
  real_type IDENTIFIER { $$ = std::list<Argument>(); $$.push_front(Argument($2, $1)); }
  | type_list COMMA real_type IDENTIFIER { $1.push_back(Argument($4, $3)); $$ = $1; }
;

statements:
  /* empty */ { $$ = std::list<ASTStatement*>(); }
  | statements statement { $1.push_back($2); $$ = $1; }
;

statement:
  left_hand EQUAL expression SEMICOL { $$ = new ASTAssign($1,$3); }
  | WHILE LPAREN expression RPAREN body { $$ = new ASTWhile($3, $5); }
  | IF LPAREN expression RPAREN body { $$ = new ASTIf($3, $5); }
  | IF LPAREN expression RPAREN body ELSE body { $$ = new ASTIf($3, $5, $7); }
  | RETURN expression SEMICOL { $$ = new ASTReturn($2); }
  | RETURN SEMICOL { $$ = new ASTReturn(); }
  | IDENTIFIER LPAREN optional_expression_list RPAREN SEMICOL { $$ = new ASTCall($1, $3); }
;

left_hand:
  IDENTIFIER { $$ = new ASTLeftHand($1); }
;

body:
  SEMICOL { $$ = std::list<ASTStatement*>(); }
  | statement { $$ = std::list<ASTStatement*>(); $$.push_back($1); }
  | LBRACE statements RBRACE { $$ = $2; }

expression:
  NUMBER { $$ = new ASTNumber($1); }
  | IDENTIFIER { $$ = new ASTReference($1); }
  | IDENTIFIER LPAREN optional_expression_list RPAREN { $$ = new ASTCall($1, $3); }
  | LPAREN expression RPAREN { $$ = $2; }
  | expression PLUS expression { $$ = new ASTBinaryExpression(Binary::ADDITION, $1, $3); }
  | expression MINUS expression { $$ = new ASTBinaryExpression(Binary::SUBTRACTION, $1, $3); }
  | expression AND expression { $$ = new ASTBinaryExpression(Binary::AND, $1, $3); }
  | expression OR expression { $$ = new ASTBinaryExpression(Binary::OR, $1, $3); }
  | expression XOR expression { $$ = new ASTBinaryExpression(Binary::XOR, $1, $3); }
  | expression COMP expression { $$ = new ASTBinaryExpression($2, $1, $3); }

  | MINUS expression { $$ = new ASTUnaryExpression(Unary::NEG, $2); }
  | BANG expression { $$ = new ASTUnaryExpression(Unary::NOT, $2); }

;

optional_expression_list:
  /* empty */ { $$ = std::list<ASTExpression*>(); }
  | expression_list { $$ = $1; }

expression_list:
  expression { $$ = std::list<ASTExpression*>(); $$.push_back($1); }
  | expression_list COMMA expression { $1.push_back($3); }

%%

void nanoc::Parser::error(const location_type& l, const std::string& m)
{
  compiler.error(l,m);
}
