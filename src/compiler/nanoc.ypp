%skeleton "lalr1.cc"
%require "3.0.2"

%defines
%define api.namespace {nanoc}
%define parser_class_name {Parser}

%define api.token.constructor
%define api.value.type variant
%define parse.assert true

%code requires {
  #include "ast.h"

  namespace nanoc
  {
    class Lexer;
    class Compiler;
  }
}

%lex-param { nanoc::Lexer &lexer }
%lex-param { nanoc::Compiler &compiler }
%parse-param { nanoc::Lexer &lexer }
%parse-param { nanoc::Compiler &compiler }

%locations
%initial-action
{
  @$.begin.filename = @$.end.filename = &compiler.file;
};

%define parse.trace
%define parse.error verbose

%code top {
  #include "compiler.h"
  #include "nanoclexer.h"
  #include "nanocparser.hpp"
  
  static nanoc::Parser::symbol_type yylex(nanoc::Lexer &scanner, nanoc::Compiler &compiler) {
    return scanner.get_next_token();
  }
  
  using namespace nanoc;
}

%define api.token.prefix {T_}
%token
  END 0 "end of file"
  EOL "\n"
  COLON ":"
  COMMA ","
  SEMICOL ";"
  LPAREN "("
  RPAREN ")"
  QUOTE "\""
  RBRACK "["
  LBRACK "]"
  STAR "*"
;

%token <Type> TYPE "type";

%token <std::string>
  IDENTIFIER "identifier"
  LITERAL "string literal"
;

%token<u16> U16 "numeric constant"

%type<ASTNode*> instruction, instructions;

%printer { yyoutput << $$; } <*>

%%

start:
  { } instructions { }
;

instructions:
  | instructions instruction { }
  | instructions EOL { }
  /*| instructions label EOL { }*/
;

instruction: 
  | TYPE IDENTIFIER SEMICOL { $$ = compiler.createDeclaration($2, $1, 0); $$->recursivePrint(0); };

%%

void nanoc::Parser::error(const location_type& l, const std::string& m)
{
  compiler.error(l,m);
}
