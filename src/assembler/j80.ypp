%skeleton "lalr1.cc"
%require "3.0.2"

%defines
%define api.namespace {Assembler}
%define parser_class_name {Parser}

%define api.token.constructor
%define api.value.type variant
%define parse.assert true

%code requires {
  #include "opcodes.h"
  #include "instruction.h"

  namespace Assembler
  {
    class Lexer;
    class J80Assembler;
  }
}

%lex-param { Assembler::Lexer &lexer }
%lex-param { Assembler::J80Assembler &assembler }
%parse-param { Assembler::Lexer &lexer }
%parse-param { Assembler::J80Assembler &assembler }

%locations
%initial-action
{
  @$.begin.filename = @$.end.filename = &assembler.file;
};

%define parse.trace
%define parse.error verbose

%code top {
  #include "assembler.h"
  #include "j80lexer.h"
  #include "j80parser.hpp"
  #include "instruction.h"
  
  static Assembler::Parser::symbol_type yylex(Assembler::Lexer &scanner, Assembler::J80Assembler &assembler) {
    return scanner.get_next_token();
  }
  
  using namespace Assembler;
}

%define api.token.prefix {T_}
%token
  END 0 "end of file"
  EOL "\n"
  COLON ":"
  COMMA ","
  LPAREN "("
  RPAREN ")"
  QUOTE "\""
  RBRACK "["
  LBRACK "]"
;

%token <std::string>
  STRING "identifier"
  LITERAL "string literal"
;

%token <Reg>
  REG8
  REG16
;

%token <u16> U16;

%token <AluOp> ALU;

%token <JumpCondition>
  JMP
  CALL
  RET
;

%token <u8> INTSTART;


%token
  LD
  ST
  LF
  SF
  LSH
  RSH
  CMP
  PUSH
  POP
  EI
  DI
  SEXT
  NOP
  DATA_ASCII ".ascii"
  DATA_CONST ".const"
  DATA_RESERVE ".reserve"
  DATA_RAW ".raw"
  DATA_LENGTH "LENGTH"
  ENTRY ".entry"
  INTERRUPT ".interrupt"
  STACK_BASE ".stackbase"
;

%type<Value8> value8


%printer { yyoutput << $$; } <*>
%printer { yyoutput << ""; } <Value8>

%%

start:
  { } instructions { }
;

instructions:
  | instructions instruction { }
  | instructions EOL { }
  /*| instructions label EOL { }*/
;

instruction:
  
  LD REG8 COMMA REG8 { assembler.assembleLD_RSH_LSH($2, $4, ALU_TRANSFER_A8, false); }
| LD REG8 COMMA value8 { assembler.add(new InstructionLD_NN($2, $4)); }

| LD REG16 COMMA REG16 { assembler.assembleLD_RSH_LSH($2, $4, ALU_TRANSFER_A16, true); }

| LD REG8 COMMA LBRACK U16 RBRACK { assembler.assembleLD_PTR_NNNN($2, $5); }
| LD REG8 COMMA LBRACK STRING RBRACK { assembler.assembleLD_PTR_NNNN($2, 0, $5, 0); }
| LD REG8 COMMA LBRACK STRING U16 RBRACK { assembler.assembleLD_PTR_NNNN($2, 0, $5, (s8)$6); }

| LD REG8 COMMA LBRACK REG16 U16 RBRACK { assembler.assembleLD_PTR_PP($2, $5, (s8)$6); }
| LD REG8 COMMA LBRACK REG16 RBRACK { assembler.assembleLD_PTR_PP($2, $5, 0); }

| LD REG16 COMMA U16 { assembler.add(new InstructionLD_NNNN($2, $4)); }
| LD REG16 COMMA STRING { assembler.add(new InstructionLD_NNNN($2, $4)); }
| LD REG16 COMMA DATA_LENGTH LPAREN STRING RPAREN { assembler.add(new InstructionLD_NNNN($2, $6)); }

| ST LBRACK U16 RBRACK COMMA REG8 { assembler.assembleSD_PTR_NNNN($6, $3); }
| ST LBRACK STRING RBRACK COMMA REG8 { assembler.assembleSD_PTR_NNNN($6, 0, $3, 0); }
| ST LBRACK STRING U16 RBRACK COMMA REG8 { assembler.assembleSD_PTR_NNNN($7, 0, $3, (s8)$4); }
| ST LBRACK REG16 U16 RBRACK COMMA REG8 { assembler.assembleSD_PTR_PP($7, $3, (s8)$4); }
| ST LBRACK REG16 RBRACK COMMA REG8 { assembler.assembleSD_PTR_PP($6, $3, 0); }


| ALU REG8 COMMA REG8 COMMA REG8 { assembler.assembleALU_REG($2, $4, $6, $1, false); }
| ALU REG8 COMMA REG8 { assembler.assembleALU_REG($2, $2, $4, $1, false); }
| ALU REG8 { assembler.assembleALU_REG($2, $2, $2, $1, false); }

| ALU REG16 COMMA REG16 COMMA REG16 { assembler.assembleALU_REG($2, $4, $6, $1, true); }
| ALU REG16 COMMA REG16 { assembler.assembleALU_REG($2, $2, $4, $1, true); }
| ALU REG16 { assembler.assembleALU_REG($2, $2, $2, $1, true); }

| ALU REG8 COMMA U16 { assembler.assembleALU_NN($2, $2, $1, (u8)$4); }
| ALU REG16 COMMA U16 { assembler.assembleALU_NNNN($2, $2, $1, $4); }
| ALU REG8 COMMA REG8 COMMA U16 { assembler.assembleALU_NN($2, $4, $1, $6); }
| ALU REG16 COMMA REG16 COMMA U16 { assembler.assembleALU_NNNN($2, $4, $1, $6); }

| LSH REG8 COMMA REG8 { assembler.assembleLD_RSH_LSH($2, $4, ALU_LSH8, false); }
| RSH REG8 COMMA REG8 { assembler.assembleLD_RSH_LSH((Reg)$2, $4, ALU_RSH8, false); }
| LSH REG8 { assembler.assembleLD_RSH_LSH((Reg)$2, $2, ALU_LSH8, false); }
| RSH REG8 { assembler.assembleLD_RSH_LSH((Reg)$2, $2, ALU_RSH8, false); }
| LSH REG16 COMMA REG16 { assembler.assembleLD_RSH_LSH($2, (Reg)$4, ALU_LSH16, false); }
| RSH REG16 COMMA REG16 { assembler.assembleLD_RSH_LSH($2, (Reg)$4, ALU_RSH16, false); }
| LSH REG16 { assembler.assembleLD_RSH_LSH($2, $2, ALU_LSH16, false); }
| RSH REG16 { assembler.assembleLD_RSH_LSH($2, $2, ALU_RSH16, false); }

| SEXT REG8 {
  if ($2 != REG_A || $2 != REG_D || $2 != REG_F || $2 != REG_X)
  {
    error(@2, "SEXT instruction can be executed only on lower regs (A, D, F or X)"); YYERROR;
  }

  assembler.add(new InstructionSEXT($2));
}

| JMP STRING { assembler.add(new InstructionJMP_NNNN($1, $2)); }
| JMP U16 { assembler.add(new InstructionJMP_NNNN($1, $2)); }
| JMP REG16 { assembler.assembleJMP_PP($1, (Reg)$2); }
| CALL STRING { assembler.add(new InstructionCALL_NNNN($1, $2)); }
| CALL U16 { assembler.add(new InstructionCALL_NNNN($1, $2)); }
| RET { assembler.add(new InstructionRET($1)); }

| PUSH REG8 { assembler.assembleShortWithReg(OPCODE_PUSH, $2); }
| POP REG8 { assembler.assembleShortWithReg(OPCODE_POP, $2); }

| PUSH REG16 { assembler.add(new InstructionPUSH16($2)); }
| POP REG16 { assembler.add(new InstructionPOP16($2)); }

| LF REG8 { assembler.assembleShortWithReg(OPCODE_LF, $2); }
| SF REG8 { assembler.assembleShortWithReg(OPCODE_SF, $2); }

| EI { assembler.assembleShort(OPCODE_EI); }
| DI { assembler.assembleShort(OPCODE_DI); }
| NOP { assembler.add(new InstructionNOP()); }

| CMP REG8 COMMA REG8 { assembler.assembleCMP_REG($2, $4, false); }
| CMP REG16 COMMA REG16 { assembler.assembleCMP_REG($2, $4, true); }
| CMP REG8 COMMA U16 { assembler.assembleCMP_NN($2, (u8)$4); }
| CMP REG16 COMMA U16 { assembler.assembleCMP_NNNN($2, $4); }
| CMP REG8 { assembler.assembleCMP_NN($2, 0); }
| CMP REG16 { assembler.assembleCMP_NNNN($2, 0); }

| DATA_ASCII STRING LITERAL { assembler.addAsciiData($2,$3); }
| DATA_RESERVE STRING U16 { assembler.addEmptyData($2,$3); }
| DATA_CONST STRING U16 { }

| ENTRY U16 { if (!assembler.setEntryPoint($2)) { error(@1, "entry point specified more than once"); YYERROR; } }

| INTERRUPT U16 {
  if ($2 >= assembler.maxNumberOfInterrupts())
  {
    error(@1, "interrupt index specified over maximum allowed index"); YYERROR;
  }
  else if (!assembler.isInterruptAvailable($2))
  {
    error(@1, "interrupt already specified for the index"); YYERROR;
  }
  else
  {
    assembler.markInterrupt($2);
    assembler.add(new InterruptEntryPoint($2));
  }
}

| STACK_BASE U16 {
  if (!assembler.setStackBase($2)) {
    error(@1, "stack base specified more than once"); YYERROR;
  }
  
}

| STRING COLON { assembler.add(new Label($1)); }

/*  | JUMP STRING EOL { ASSEMBLER->asmJump($2, false); }
  | JUMPC STRING EOL { ASSEMBLER->asmJump($2, true); }*/

;

value8:
U16 {
  if (!valueFitsType<u8>($1)) {
    error(@1, "8bit value exceeds range: " + std::to_string((s16)$1));
    YYERROR;
  }
  $$ = Value8($1);
}
| DATA_LENGTH LPAREN STRING RPAREN { $$ = Value8($3); }

/*
label:
  STRING COLON { ASSEMBLER->addLabelHere($1); }
;*/

%%

void Assembler::Parser::error(const location_type& l, const std::string& m)
{
  assembler.error(l,m);
}
