%{
  #include "assembler.h"
  #include "opcodes.h"
  
  #define YYDEBUG 0
  
  extern FILE *ncin;

	extern "C"
	{
    typedef struct yy_buffer_state *YY_BUFFER_STATE;
    
    int ncparse(void);
    int nclex(void);
    //int cyywrap();
    /*{
     return 1;
     }*/
    void ncerror(const char *s);
        
    extern int nclineno;
    extern char *nctext;
    
    extern int ncparse();

    //extern YY_BUFFER_STATE yy_scan_string(const char *line);
    extern void yy_delete_buffer(YY_BUFFER_STATE);
    extern void yy_switch_to_buffer(YY_BUFFER_STATE);
    
    
	}
  
    static bool failed = false;
    
    bool correctRSTAddress(u16 val);
%}

%union
{
	unsigned short us;
  signed short ss;
	char *str;
}

%token T_EOL T_COLON T_COMMA T_LPAREN T_RPAREN T_QUOTE T_RBRACK T_LBRACK TOKEN_LENGTH

%token TOKEN_REG8 TOKEN_REG16
%token TOKEN_ALU TOKEN_COND TOKEN_NEAR
%token TOKEN_LD TOKEN_JMP TOKEN_ST TOKEN_LF TOKEN_SF TOKEN_LSH TOKEN_RSH TOKEN_CMP
%token TOKEN_CALL TOKEN_RET TOKEN_PUSH TOKEN_POP TOKEN_INT TOKEN_EI TOKEN_DI TOKEN_NOP
%token TOKEN_DATA_ASCII TOKEN_DATA_RESERVE TOKEN_DATA_RAW
%token TOKEN_INTERRUPT TOKEN_INTERRUPT_END

%token U16 STRING STRING_LITERAL

%type<us> instruction

%type<us> TOKEN_REG8 TOKEN_REG16 TOKEN_ALU TOKEN_JMP TOKEN_RET TOKEN_CALL TOKEN_INTERRUPT

%type<us> U16
%type<str> STRING STRING_LITERAL

%%

start:
  { Assembler::init(); } instructions { }
;

instructions:
  | instructions instruction { }
  | instructions T_EOL { }
  /*| instructions label T_EOL { }*/
;

instruction:
  
%%

void ncerror(const char *s)
{
	failed = true;
	fprintf(stderr, "PARSING ERROR on line %d!  Parse error: %s\n", nclineno, nctext);
}
